package parsers

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"html"
	"io"
	"log"
	"net/http"
	"net/url"
	"sort"
	"strconv"
	"strings"
	"time"

	"github.com/PuerkitoBio/goquery"
	perrors "github.com/Quavke/AnimeParsersGo/errors"
)

type Client struct {
	httpClient *http.Client
}

type AniboomParser struct {
	dmn     string
	Client  *Client
	Context context.Context
}

func NewAniboomParser(mirror string) *AniboomParser {
	var dmn string
	if mirror != "" {
		dmn = mirror
	} else {
		dmn = "animego.me"
	}
	client := &Client{
		&http.Client{Timeout: 10 * time.Second},
	}
	return &AniboomParser{
		dmn:     dmn,
		Client:  client,
		Context: context.Background(),
	}
}

type FastSearchResult struct {
	Title      string `json:"title"`
	Year       string `json:"year"`
	OtherTitle string `json:"other_title"`
	Type       string `json:"type"`
	Link       string `json:"link"`
	AnimegoID  string `json:"animego_id"`
}

type JsonResponse struct {
	Status  string `json:"status"`
	Content string `json:"content"`
	Message string `json:"message,omitempty"`
}

type EpisodeInfo struct {
	Num    string `json:"num"`
	Title  string `json:"title"`
	Date   string `json:"date"`
	Status string `json:"status"`
}

type Translation struct {
	Name          string `json:"name"`
	TranslationID string `json:"translation_id"`
}

type OtherAnimeInfo struct {
	AgeRests       string   `json:"age_restrictions"`
	ReleaseDate    string   `json:"release_date"`
	MainCharacters []string `json:"main_characters"`
	Duration       string   `json:"duration"`
	OriginalSource string   `json:"original_source"`
	MPAARating     string   `json:"mpaa_rating"`
	Season         string   `json:"season"`
	OriginalRanobe string   `json:"ranobe"`
	OriginalManga  string   `json:"manga"`
	Studio         string   `json:"studio"`
}
type SearchResult struct {
	Title        string            `json:"title"`
	OtherTitle   string            `json:"other_title"`
	Status       string            `json:"status"`
	Type         string            `json:"type"`
	Genres       []string          `json:"genres"`
	Description  string            `json:"description"`
	Episodes     string            `json:"episodes"`
	EpisodesInfo []*EpisodeInfo    `json:"episodes_info"`
	Translations []*Translation    `json:"translations"`
	PosterURL    string            `json:"poster_url"`
	Trailer      string            `json:"trailer"`
	Screenshots  []string          `json:"screenshots"`
	OtherInfo    *OtherAnimeInfo   `json:"other_info"`
	Link         string            `json:"link"`
	AnimegoID    string            `json:"animego_id"`
	Unparsed     map[string]string `json:"unparsed"`
}

/*
Быстрый поиск через animego.me

:title: Название аниме

Возвращает срез ссылок на FastSearchResult
*/
func (ab *AniboomParser) FastSearch(title string) (*[]FastSearchResult, error) {
	params := url.Values{}

	params.Set("type", "small")
	params.Set("q", title)
	domain := fmt.Sprintf("https://%s/", ab.dmn)
	URL := fmt.Sprintf("%ssearch/all?%s", domain, params.Encode())
	request, err := http.NewRequest("GET", URL, nil)
	if err != nil {
		error_message := fmt.Sprintf("Aniboom parser error : FastSearch : не смог создать request. Ошибка: %v", err)
		log.Println(error_message)
		return nil, perrors.NewServiceError(error_message)
	}

	request.Header.Set("Accept", "application/json, text/javascript, */*; q=0.01")
	request.Header.Set("X-Requested-With", "XMLHttpRequest")
	request.Header.Set("Referer", domain)

	resp, err := ab.Client.httpClient.Do(request)
	if err != nil || resp.StatusCode != http.StatusOK {
		error_message := fmt.Sprintf("Aniboom parser error : FastSearch : http клиент не смог выполнить запрос. Ошибка: %v", err)
		log.Println(error_message)
		return nil, perrors.NewServiceError(error_message)
	}
	defer resp.Body.Close()

	var json_response JsonResponse

	if err := json.NewDecoder(resp.Body).Decode(&json_response); err != nil {
		return nil, perrors.NewJsonDecodeFailureError(fmt.Sprintf("Aniboom parser error : FastSearch : ошибка декодирования json: %v", err))
	}

	if json_response.Status != "success" {
		return nil, perrors.NewServiceError(fmt.Sprintf(
			"Aniboom parser error : FastSearch : сервер вернул статус отличный от success: %q, сообщение: %q для названия: %q",
			json_response.Status, json_response.Message, title,
		))
	}

	htmlContent := html.UnescapeString(json_response.Content)
	doc, err := goquery.NewDocumentFromReader(strings.NewReader(htmlContent))
	if err != nil {
		error_message := fmt.Sprintf("Aniboom parser error : FastSearch : goquery не смог преобразовать ответ в документ. Ошибка: %v", err)
		log.Println(error_message)
		return nil, perrors.NewServiceError(error_message)
	}
	res := make([]FastSearchResult, 0)
	items := doc.Find("div.result-search-anime").First().Find("div.result-search-item")
	if items.Length() == 0 {
		error_message := "Aniboom parser error : FastSearch : в контейнере result-search-anime не найдено ни одного элемента div.result-search-item"
		log.Println(error_message)
		return nil, perrors.NewNoResultsError(error_message)
	}

	items.Each(func(i int, s *goquery.Selection) {
		c_data := FastSearchResult{}
		c_data.Title = strings.TrimSpace(s.Find("h5").First().Text())
		c_data.Year = strings.TrimSpace(s.Find("span.anime-year").First().Text())
		c_data.OtherTitle = s.Find("div.text-truncate").First().Text()
		c_data.Type = s.Find("a[href*=\"anime/type\"]").First().Text()
		link := s.Find("h5 a").First()
		var rawLink string
		if link.Length() > 0 {
			href, exists := link.Attr("href")
			if exists {
				rawLink = href
			}
		}
		c_data.Link = fmt.Sprintf("https://%s", ab.dmn) + rawLink
		fullLink := c_data.Link
		lastDashIndex := strings.LastIndex(fullLink, "-")
		if lastDashIndex != -1 && lastDashIndex < len(fullLink)-1 {
			c_data.AnimegoID = fullLink[lastDashIndex+1:]
		} else {
			c_data.AnimegoID = ""
		}
		fmt.Println(c_data)
		res = append(res, c_data)
	})

	return &res, nil
}

// Возвращает данные по эпизодам.
//
// :link: ссылка на страницу с данными (прим: https://animego.me/anime/volchica-i-pryanosti-torgovec-vstrechaet-mudruyu-volchicu-2546)
//
// Возвращает отсортированный по номеру серии срез ссылок на EpisodeInfo
func (ab *AniboomParser) EpisodesInfo(link string) ([]*EpisodeInfo, error) {
	episodes_info := make([]*EpisodeInfo, 0)

	params := url.Values{}
	referer := fmt.Sprintf("https://%s/search/all?q=anime", ab.dmn)
	params.Set("type", "episodeSchedule")
	params.Set("episodeNumber", "99999")

	URL := link + "?" + params.Encode()
	request, err := http.NewRequestWithContext(ab.Context, "GET", URL, nil)
	if err != nil {
		error_message := fmt.Sprintf("Aniboom parser error : EpisodesInfo : не смог создать request. Ошибка: %v", err)
		log.Println(error_message)
		return nil, perrors.NewServiceError(error_message)
	}
	request.Header.Set("Referer", referer)
	request.Header.Set("Accept", "application/json, text/javascript, */*; q=0.01")
	request.Header.Set("X-Requested-With", "XMLHttpRequest")

	resp, err := ab.Client.httpClient.Do(request)
	if err != nil {
		error_message := fmt.Sprintf("Aniboom parser error : EpisodesInfo : http клиент не смог выполнить запрос. Ошибка: %v", resp.StatusCode, err)
		log.Println(error_message)
		return nil, perrors.NewServiceError(error_message)
	}
	defer resp.Body.Close()
	if resp.StatusCode != http.StatusOK {
		error_message := fmt.Sprintf("Aniboom parser error : EpisodesInfo : Сервер не вернул ожидаемый код 200. Код: %d\n", resp.StatusCode)
		log.Println(error_message)
		return nil, perrors.NewNoResultsError(error_message)
	}

	var json_response JsonResponse

	if err := json.NewDecoder(resp.Body).Decode(&json_response); err != nil {
		return nil, perrors.NewJsonDecodeFailureError(fmt.Sprintf("Aniboom parser error : EpisodesInfo : ошибка декодирования json: %v", err))
	}

	if json_response.Status != "success" {
		return nil, perrors.NewServiceError(fmt.Sprintf(
			"Aniboom parser error : EpisodesInfo : сервер вернул статус отличный от success: %q, сообщение: %q для ссылки: %q",
			json_response.Status, json_response.Message, link,
		))
	}
	htmlContent := html.UnescapeString(json_response.Content)

	doc, err := goquery.NewDocumentFromReader(strings.NewReader(htmlContent))
	if err != nil {
		error_message := fmt.Sprintf("Aniboom parser error : EpisodesInfo : goquery не смог преобразовать ответ в документ. Ошибка: %v", err)
		log.Println(error_message)
		return nil, perrors.NewServiceError(error_message)
	}

	doc.Find("div.row.m-0").Each(func(i int, s *goquery.Selection) {
		episode_info := EpisodeInfo{}
		items := s.Find("div")
		selections := make([]*goquery.Selection, 0)
		items.Each(func(i int, s *goquery.Selection) {
			selections = append(selections, s)
		})
		num, exists := selections[0].Find("meta").Attr("content")
		if exists {
			episode_info.Num = num
		}
		episode_info.Status = "анонс"
		if selections[1].Length() > 0 {
			episode_info.Title = strings.TrimSpace(selections[1].Text())
		}
		if selections[2].Find("span").Length() > 0 {
			date, exists := selections[2].Find("span").Attr("data_label")
			if exists {
				episode_info.Date = date
			}
		}
		if selections[3].Find("span").Length() > 0 {
			episode_info.Status = "вышел"
		}
		episodes_info = append(episodes_info, &episode_info)
	})
	sort.Slice(episodes_info, func(i, j int) bool {
		numI := episodes_info[i].Num
		numJ := episodes_info[j].Num

		isDigitStr := func(s string) bool {
			if s == "" {
				return false
			}
			for _, r := range s {
				if r < '0' || r > '9' {
					return false
				}
			}
			return true
		}

		if isDigitStr(numI) && isDigitStr(numJ) {
			intI, _ := strconv.Atoi(numI)
			intJ, _ := strconv.Atoi(numJ)
			return intI < intJ
		}

		if isDigitStr(numI) && !isDigitStr(numJ) {
			return true
		}
		if !isDigitStr(numI) && isDigitStr(numJ) {
			return false
		}

		return numI < numJ
	})
	return episodes_info, nil
}

// Расширенный поиск через animego.me. Собирает дополнительные данные об аниме.
//
// :title: Название
//
// Возвращает срез ссылок на SearchResult
func (ab *AniboomParser) Search(title string) ([]*SearchResult, error) {
	elements, err := ab.FastSearch(title)
	if err != nil {
		error_message := fmt.Sprintf("Aniboom parser error : search : FastSearch не смог найти данные для title %s. Ошибка: %v", title, err)
		log.Println(error_message)
		return nil, err
	}
	res := make([]*SearchResult, 0)
	for _, anime := range *elements {
		c_data, err := ab.AnimeInfo(anime.Link)
		if err != nil {
			error_message := fmt.Sprintf("Aniboom parser error : search : AnimeInfo не смог найти данные для %s по ссылке %s. Ошибка: %v", anime.Title, anime.Link, err)
			log.Println(error_message)
			continue
		}
		res = append(res, c_data)
	}

	return res, nil
}

/*
Получение данных об аниме с его страницы на animego.me.

:link: Ссылка на страницу (прим: https:animego.me/anime/volchica-i-pryanosti-torgovec-vstrechaet-mudruyu-volchicu-2546)

Возвращает модель SearchResult
*/
func (ab *AniboomParser) AnimeInfo(link string) (*SearchResult, error) {
	var c_data SearchResult

	request, err := http.NewRequestWithContext(ab.Context, "GET", link, nil)
	if err != nil {
		error_message := fmt.Sprintf("Aniboom parser error : AnimeInfo : не смог создать request. Ошибка: %v", err)
		log.Println(error_message)
		return nil, perrors.NewServiceError(error_message)
	}

	URL := fmt.Sprintf("https://%s/search/all?q=anime", ab.dmn)

	request.Header.Set("Referer", URL)
	request.Header.Set("X-Requested-With", "XMLHttpRequest")
	request.Header.Set("Accept", "application/json, text/javascript, */*; q=0.01")
	//https://animego.me/anime/vrata-shteyna-egoistichnaya-poriomaniya-343
	//https:animego.me/anime/vrata-shteyna-egoistichnaya-poriomaniya-343
	resp, err := ab.Client.httpClient.Do(request)
	if err != nil {
		error_message := fmt.Sprintf("Aniboom parser error : AnimeInfo : http клиент не смог выполнить запрос. Ошибка: %v", err)
		log.Println(error_message)
		return nil, perrors.NewServiceError(error_message)
	} else if resp.StatusCode == http.StatusTooManyRequests {
		error_message := "Aniboom parser error : AnimeInfo : Сервер вернул код ошибки 429. Слишком частые запросы"
		log.Println(error_message)
		return nil, perrors.NewTooManyRequestsError(error_message)
	} else if resp.StatusCode != http.StatusOK {
		log.Printf("Aniboom parser error : AnimeInfo : Сервер не вернул ожидаемый код 200. Код: %d\n", resp.StatusCode)
	}
	defer resp.Body.Close()
	var json_response JsonResponse

	if err := json.NewDecoder(resp.Body).Decode(&json_response); err != nil {
		body, _ := io.ReadAll(resp.Body)
		return nil, perrors.NewJsonDecodeFailureError(fmt.Sprintf(
			"Aniboom parser error : AnimeInfo : ошибка декодирования json: %v. Ответ сервера: %.2500s...",
			err, string(body),
		))
		// return nil, perrors.NewJsonDecodeFailureError(fmt.Sprintf("Aniboom parser error : FastSearch : ошибка декодирования json: %v", err))
	}

	if json_response.Status != "success" {
		return nil, perrors.NewServiceError(fmt.Sprintf(
			"Aniboom parser error : AnimeInfo : сервер вернул статус отличный от success: %q, сообщение: %q для ссылки: %q",
			json_response.Status, json_response.Message, link,
		))
	}

	htmlContent := html.UnescapeString(json_response.Content)
	doc, err := goquery.NewDocumentFromReader(strings.NewReader(htmlContent))
	if err != nil {
		error_message := fmt.Sprintf("Aniboom parser error : AnimeInfo : goquery не смог преобразовать ответ в документ. Ошибка: %v", err)
		log.Println(error_message)
		return nil, perrors.NewServiceError(error_message)
	}
	c_data.Link = link
	fullLink := c_data.Link
	lastDashIndex := strings.LastIndex(fullLink, "-")
	if lastDashIndex != -1 && lastDashIndex < len(fullLink)-1 {
		c_data.AnimegoID = fullLink[lastDashIndex+1:]
	} else {
		c_data.AnimegoID = ""
	}
	dmn := fmt.Sprintf("https://%s", ab.dmn)
	c_data.Title = strings.TrimSpace(doc.Find("div.anime-title h1").Text())
	poster_url_doc := doc.Find("img").First()
	if poster_url_doc.Length() > 0 {
		src, exists := poster_url_doc.Attr("src")
		if exists {
			c_data.PosterURL = src

			SlashIndex := strings.Index(c_data.PosterURL, "/upload")
			if SlashIndex != -1 && SlashIndex < len(c_data.PosterURL)-1 {
				c_data.PosterURL = c_data.PosterURL[SlashIndex+1:]
			} else {
				c_data.PosterURL = ""
			}
			if len(c_data.PosterURL) > 0 {
				c_data.PosterURL = dmn + c_data.PosterURL
			}
		}
	}
	anime_info := doc.Find("div.anime-info dl").First()
	if anime_info.Length() == 0 {
		error_message := "Aniboom parser error : AnimeInfo : doc.Find(\"div.anime-info dl\") не смог найти тег dl"
		log.Println(error_message)
		return nil, perrors.NewNoResultsError(error_message)
	}
	var allDTs []*goquery.Selection
	var allDDs []*goquery.Selection

	anime_info.Find("dt").Each(func(i int, s *goquery.Selection) {
		allDTs = append(allDTs, s)
	})

	anime_info.Find("dd").Each(func(i int, s *goquery.Selection) {
		skip := false

		if s.HasClass("mt-2") && s.HasClass("col-12") {
			skip = true
		}

		if s.Find("hr").First().Length() > 0 {
			skip = true
		}

		if !skip {
			allDDs = append(allDDs, s)
		}
	})
	other_anime_info := make(map[string]string, 0)
	var OtherAniInfo OtherAnimeInfo
	minLen := len(allDTs)
	if minLen > len(allDDs) {
		minLen = len(allDDs)
	}

	for i := 0; i < minLen; i++ {
		key := strings.TrimSpace(allDTs[i].Text())
		value := strings.TrimSpace(allDDs[i].Text())

		if key != "" && value != "" {
			other_anime_info[key] = value
		}
	}

	for i := 0; i < len(allDTs); i++ {
		key := strings.TrimSpace(allDTs[i].Text())
		value := strings.TrimSpace(allDDs[i].Text())
		if key == "Озвучка" {
			continue
		} else if key == "Жанр" {
			genres := make([]string, 0)
			allDDs[i].Find("a").Each(func(i int, s *goquery.Selection) {
				genres = append(genres, strings.TrimSpace(s.Text()))
			})
			c_data.Genres = genres
		} else if key == "Главные герои" {
			main_characters := make([]string, 0)
			allDDs[i].Find("a").Each(func(i int, s *goquery.Selection) {
				main_characters = append(main_characters, strings.TrimSpace(s.Text()))
			})
			OtherAniInfo.MainCharacters = main_characters
		} else if key == "Эпизоды" {
			c_data.Episodes = value
		} else if key == "Статус" {
			c_data.Status = value
		} else if key == "Тип" {
			c_data.Type = value
		} else {
			switch key {
			case "Возрастные ограничения":
				OtherAniInfo.AgeRests = value
			case "Выпуск":
				OtherAniInfo.ReleaseDate = value
			case "Длительность":
				OtherAniInfo.Duration = value
			case "Первоисточник":
				OtherAniInfo.OriginalSource = value
			case "Рейтинг MPAA":
				OtherAniInfo.MPAARating = value
			case "Сезон":
				OtherAniInfo.Season = value
			case "Снят по ранобэ":
				OtherAniInfo.OriginalRanobe = value
			case "Снят по манге":
				OtherAniInfo.OriginalManga = value
			case "Студия":
				OtherAniInfo.Studio = value
			default:
				c_data.Unparsed[key] = value
			}
		}
	}

	c_data.Description = strings.TrimSpace(doc.Find("div.description").Text())
	screenshots_urls := make([]string, 0)
	doc.Find("a.screenshots-item").Each(func(i int, s *goquery.Selection) {
		href, exists := s.Attr("href")
		if exists {
			URL := dmn + strings.TrimSpace(href)
			screenshots_urls = append(screenshots_urls, URL)
		}
	})
	c_data.Screenshots = screenshots_urls

	trailer_cont := doc.Find("a.video-block")
	if trailer_cont.Length() > 0 {
		href, exists := trailer_cont.Find("a.video-item").Attr("href")
		if exists {
			c_data.Trailer = strings.TrimSpace(href)
		}
	}
	result, err := ab.EpisodesInfo(link)
	if err != nil {
		error_message := fmt.Sprintf("Aniboom parser error : AnimeInfo : EpisodesInfo вернул неожиданную ошибку: %v", err)
		log.Println(error_message)
		return nil, err
	}

	c_data.EpisodesInfo = result

	translations_info, err := ab.GetTranslationsInfo(c_data.AnimegoID)
	var contentBlocked *perrors.ContentBlocked
	if errors.As(err, &contentBlocked) {
		log.Println("Aniboom parser warning : AnimeInfo : GetTranslationsInfo вернул ошибку ContentBlocked")
	} else if err != nil {
		error_message := fmt.Sprintf("Aniboom parser error : AnimeInfo : GetTranslationsInfo вернул неожиданную ошибку: %v", err)
		log.Println(error_message)
		return nil, perrors.NewServiceError(error_message)
	} else {
		c_data.Translations = translations_info
	}

	c_data.OtherInfo = &OtherAniInfo
	return &c_data, nil
}

// Получает информацию о переводах и их id для плеера aniboom
//
// :animego_id: id аниме на animego.me
//
// Возвращает срез ссылок на Translation:
func (ab *AniboomParser) GetTranslationsInfo(animego_id string) ([]*Translation, error) {
	translations := make([]*Translation, 0)

	params := url.Values{}

	params.Set("_allow", "true")

	URL := fmt.Sprintf("https://%s/anime/%s/player?", ab.dmn, animego_id) + params.Encode()

	request, err := http.NewRequestWithContext(ab.Context, "GET", URL, nil)

	if err != nil {
		error_message := fmt.Sprintf("Aniboom parser error : GetTranslationsInfo : не смог создать request. Ошибка: %v", err)
		log.Println(error_message)
		return nil, perrors.NewServiceError(error_message)
	}

	referer := fmt.Sprintf("https://%s/search/all?q=anime", ab.dmn)
	request.Header.Set("X-Requested-With", "XMLHttpRequest")
	request.Header.Set("Referer", referer)

	resp, err := ab.Client.httpClient.Do(request)
	if err != nil {
		error_message := fmt.Sprintf("Aniboom parser error : GetTranslationsInfo :  http клиент не смог выполнить запрос. Ошибка: %v", err)
		log.Println(error_message)
		return nil, perrors.NewServiceError(error_message)
	}
	defer resp.Body.Close()
	if resp.StatusCode == http.StatusTooManyRequests {
		return nil, perrors.NewTooManyRequestsError("Aniboom parser error : GetTranslationsInfo : Сервер вернул код ошибки 429. Слишком частые запросы")
	}
	if resp.StatusCode != http.StatusOK {
		error_message := fmt.Sprintf("Aniboom parser error : GetTranslationsInfo : Сервер не вернул ожидаемый код 200. Код: %d", resp.StatusCode)
		log.Println(error_message)
		return nil, perrors.NewServiceError(error_message)
	}

	var json_response JsonResponse

	if err := json.NewDecoder(resp.Body).Decode(&json_response); err != nil {
		return nil, perrors.NewJsonDecodeFailureError(fmt.Sprintf("Aniboom parser error : GetTranslationsInfo : ошибка декодирования json: %v", err))
	}

	if json_response.Status != "success" {
		return nil, perrors.NewServiceError(fmt.Sprintf(
			"Aniboom parser error : FastSearch : сервер вернул статус отличный от success: %q, сообщение: %q для animegoID: %q",
			json_response.Status, json_response.Message, animego_id,
		))
	}

	htmlContent := html.UnescapeString(json_response.Content)
	doc, err := goquery.NewDocumentFromReader(strings.NewReader(htmlContent))
	if err != nil {
		error_message := fmt.Sprintf("Aniboom parser error : GetTranslationsInfo : goquery не смог преобразовать ответ в документ. Ошибка: %v", err)
		log.Println(error_message)
		return nil, perrors.NewServiceError(error_message)
	}

	if doc.Find("div.player-blocked").Length() > 0 {
		reason_elem := doc.Find("div.h5")
		if reason_elem.Length() > 0 {
			reason := strings.TrimSpace(reason_elem.Text())
			error_message := fmt.Sprintf("Aniboom parser error : GetTranslationsInfo : Контент по id %s заблокирован. Причина блокировки: \"%s\"", animego_id, reason)
			log.Println(error_message)
			return nil, perrors.NewContentBlockedError(error_message)
		}
	}
	translations_container := doc.Find("div#video-dubbing").First().Find("span.video-player-toggle-item")
	players_container := doc.Find("div#video-players").First().Find("span.video-player-toggle-item")
	translation := make(map[string]*Translation)

	translations_container.Each(func(i int, s *goquery.Selection) {
		dubbing, exists := s.Attr("data-dubbing")
		if !exists || dubbing == "" {
			return
		}

		name := strings.TrimSpace(s.Text())
		if name == "" {
			return
		}

		if _, exists := translation[dubbing]; !exists {
			translation[dubbing] = &Translation{}
		}

		translation[dubbing].Name = name
	})
	players_container.Each(func(i int, s *goquery.Selection) {
		provider, exists := s.Attr("data-provider")
		if !exists || provider != "24" {
			return
		}

		dubbing, exists := s.Attr("data-provide-dubbing")
		if !exists || dubbing == "" {
			return
		}

		if _, exists := translation[dubbing]; !exists {
			translation[dubbing] = &Translation{}
		}

		translationID, exists := s.Attr("data-player")
		if !exists || translationID == "" {
			return
		}

		lastIndex := strings.LastIndex(translationID, "=")
		if lastIndex != -1 && lastIndex < len(translationID)-1 {
			translationID = translationID[lastIndex+1:]
		}

		translation[dubbing].TranslationID = translationID
	})

	for _, translation_info := range translation {
		if len(translation_info.Name) > 0 && len(translation_info.TranslationID) > 0 {
			translations = append(translations, translation_info)
		}
	}

	return translations, nil
}

// Возвращает ссылку на embed от aniboom. Сама по себе ссылка не может быть использована, однако требуется для дальнейшего парсинга.
//
// :animego_id: id аниме на animego.me
//
// Возвращает ссылку в виде: https://aniboom.one/embed/yxVdenrqNar
// Если ссылка не найдена, выкидывает NoResults exception
func (ab *AniboomParser) get_embed_link(animego_id string) (string, error) {
	params := url.Values{}

	params.Set("_allow", "true")

	URL := fmt.Sprintf("https://%s/anime/%s/player?%s", ab.dmn, animego_id, params.Encode())

	request, err := http.NewRequestWithContext(ab.Context, "GET", URL, nil)
	if err != nil {
		error_message := fmt.Sprintf("Aniboom parser error : get_embed_link : не смог создать request. Ошибка: %v", err)
		log.Println(error_message)
		return "", perrors.NewServiceError(error_message)
	}
	request.Header.Set("X-Requested-With", "XMLHttpRequest")

	resp, err := ab.Client.httpClient.Do(request)
	if err != nil {
		error_message := fmt.Sprintf("Aniboom parser error : get_embed_link :  http клиент не смог выполнить запрос, код: %d. Ошибка: %v", resp.StatusCode, err)
		log.Println(error_message)
		return "", perrors.NewServiceError(error_message)
	}
	defer resp.Body.Close()
	if resp.StatusCode == http.StatusTooManyRequests {
		return "", perrors.NewTooManyRequestsError("Aniboom parser error : get_embed_link : Сервер вернул код ошибки 429. Слишком частые запросы")
	}
	if resp.StatusCode != http.StatusOK {
		error_message := fmt.Sprintf("Aniboom parser error : get_embed_link : Сервер не вернул ожидаемый код 200. Код: %d", resp.StatusCode)
		log.Println(error_message)
		return "", perrors.NewServiceError(error_message)
	}

	var json_response JsonResponse

	if err := json.NewDecoder(resp.Body).Decode(&json_response); err != nil {
		return "", perrors.NewJsonDecodeFailureError(fmt.Sprintf("Aniboom parser error : GetTranslationsInfo : ошибка декодирования json: %v", err))
	}

	if json_response.Status != "success" {
		return "", perrors.NewServiceError(fmt.Sprintf(
			"Aniboom parser error : FastSearch : сервер вернул статус отличный от success: %q, сообщение: %q для animegoID: %q",
			json_response.Status, json_response.Message, animego_id,
		))
	}

	htmlContent := html.UnescapeString(json_response.Content)
	doc, err := goquery.NewDocumentFromReader(strings.NewReader(htmlContent))
	if err != nil {
		error_message := fmt.Sprintf("Aniboom parser error : get_embed_link : goquery не смог преобразовать ответ в документ. Ошибка: %v", err)
		log.Println(error_message)
		return "", perrors.NewServiceError(error_message)
	}

	items := doc.Find("div.player-blocked").First()

	if items.Length() > 0 {
		reason_elem := doc.Find("div.h5").First()
		reason := ""
		if reason_elem.Length() > 0 {
			reason = strings.TrimSpace(reason_elem.Text())
		}
		return "", perrors.NewNoResultsError(fmt.Sprintf("Aniboom parser error : get_embed_link : контент по id %s заблокирован. Причина: %v", animego_id, reason))
	}
	link := doc.Find("div#video-players")

	span := link.Find("span.video-player-toggle-item[data-provider=\"24\"]").First()

	var player_link string
	if span.Length() > 0 {
		if attrValue, exists := span.Attr("data-player"); exists {
			player_link = attrValue
		} else {
			return "", perrors.NewAttributeError(fmt.Sprintf("Aniboom parser error : get_embed_link : для указанного id %s не удалось найти aniboom embed_link", animego_id))
		}
	}

	lastQuestionIndex := strings.LastIndex(player_link, "?")
	if lastQuestionIndex != -1 && lastQuestionIndex < len(player_link)-1 {
		return "https:" + player_link[:lastQuestionIndex], nil
	} else {
		return "", perrors.NewServiceError(fmt.Sprintf("Не удалось найти \"?\" для ссылки: %s", player_link))
	}
}
